<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Form窗口对象</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="styles.css" type="text/css" />
</head>
<body><div class="main"><div class="tree">
<p><strong>Index</strong></p>
<p><a href="npyscreen.html">npyscreen</a></p>

<ol>
<li><a href="npyscreen--npyscreen介绍.html">npyscreen介绍</a></li>
<li><a href="npyscreen--创建npyscreen应用程序.html">创建npyscreen应用程序</a></li>
<li><a href="npyscreen--Application应用对象.html">Application应用对象</a></li>
<li><a href="npyscreen--Form窗口对象.html">Form窗口对象</a></li>
<li><a href="npyscreen--控件基本特性.html">控件:基本特性</a></li>
<li><a href="npyscreen--控件显示文本.html">控件:显示文本</a></li>
<li><a href="npyscreen--控件选取选项.html">控件:选取选项</a></li>
<li><a href="npyscreen--控件树表与树的显示.html">控件:树表与树的显示</a></li>
<li><a href="npyscreen--控件日期,滑块和复合控件.html">控件:日期,滑块和复合控件</a></li>
<li><a href="npyscreen--控件网格.html">控件:网格</a></li>
<li><a href="npyscreen--控件其他控制.html">控件:其他控制</a></li>
<li><a href="npyscreen--控件标题控件.html">控件:标题控件</a></li>
<li><a href="npyscreen--控件控件框.html">控件:控件框</a></li>
<li><a href="npyscreen--按键绑定全解.html">按键绑定全解</a></li>
<li><a href="npyscreen--增强鼠标支持.html">增强鼠标支持</a></li>
<li><a href="npyscreen--色彩支持.html">色彩支持</a></li>
<li><a href="npyscreen--显示简讯通知及选项.html">显示简讯通知及选项</a></li>
<li><a href="npyscreen--清空屏幕.html">清空屏幕</a></li>
<li><a href="npyscreen--应用支持.html">应用支持</a></li>
<li><a href="npyscreen--编写更复杂的窗口.html">编写更复杂的窗口</a></li>
<li><a href="npyscreen--编写测试.html">编写测试</a></li>
<li><a href="npyscreen--示例程序一个简单的通讯录.html">示例程序:一个简单的通讯录</a></li>
</ol></div>
<div class="page"><h1><b><u>Form窗口对象</u></b></h1><strong><h2>Form窗口对象</h2></strong><br /><br />窗口对象就是屏幕上一个容纳控件的区域.窗口对象可以控制用户当前编辑哪个控件,并且还可能提供附加功能,比如弹出菜单和特定按键被按下应该产生的动作.<br /><br /><strong><h3>创建窗口</h3></strong><br /><br />class<code>Form</code><strong><span style="color:#2980b9;">(</span></strong><strong>name=None</strong><strong><span style="color:#2980b9;">, </span></strong><strong>lines=0</strong><strong><span style="color:#2980b9;">, </span></strong><strong>columns=0</strong><strong><span style="color:#2980b9;">, </span></strong><strong>minimum_lines=24</strong><strong><span style="color:#2980b9;">, </span></strong><strong>minimum_columns=80</strong><strong><span style="color:#2980b9;">)</span></strong><br /><br />窗口具有以下类属性:<br /><div class="codebox"><div class="codebox">DEFAULT_LINES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;<span style="color:#ff00ff;font-weight:400">0</span><br />DEFAULT_COLUMNS&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;<span style="color:#ff00ff;font-weight:400">0</span><br />SHOW_ATX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;<span style="color:#ff00ff;font-weight:400">0</span><br />SHOW_ATY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;<span style="color:#ff00ff;font-weight:400">0</span></div></div><br /><br />使用这些默认值会创建一个填满整个屏幕的窗口,该窗口从左上角开始显示.控制窗口大小的细节参见传递进构造函数的参数.<br /><br />以下参数能被传进窗口的构造函数里:<br /><br />name=<br />&emsp;窗口的名字.对于一些控件,这个属性会显示一个标题.<br />lines=0, columns=0, minimum_lines=24, minimum_columns=80<br />&emsp;你可以调整窗口的大小,要么给出其绝对尺寸值(使用 lines= 和 columns=),要么给出其最小尺寸值(minimum_lines= 和 minimum_columns=).默认的最小值(24x80)提供了在终端上的标准大小.假如你规划好让窗口适配到这个大小以内,那么他们应该在所有的系统的界面上不滚动窗口的情况下也全可见.注意,你可以在一个方向使用绝对值大小,另一个方向上使用最小值大小,要是你需要的话.<br /><br />标准的构造函数都会调用 .create()方法,要创建窗口的控件你应该覆盖它.请看下面.<br /><br /><strong><h3>放置控件到窗口</h3></strong><br /><br />要把控件放到窗口上,用下面的方法:<br /><code>Form.add</code><strong><span style="color:#2980b9;">(</span></strong><strong>WidgetClass</strong><strong><span style="color:#2980b9;">, </span></strong><strong>...</strong><strong><span style="color:#2980b9;">)</span></strong><br />&emsp;WidgetClass必须得是一个类,所有的附加参数都会被传递到控件自己的构造函数里.控件的引用会被返回.<br /><br />控件的位置和大小由控件的构造函数控制.不过一些指示信息是由窗口类给出的.如果你不去重写控件的位置,它会根据窗口实例的 .nextrelx 和nextrely 属性值来放置.这里的 .nextrely 属性是随每次的控件放置而自增长的.你也可以自行把它加大,就像下面这样:<br /><div class="codebox"><div class="codebox"><span style="color:#008a8c;font-weight:400">self</span>.nextrely&nbsp;+=<span style="color:#ff00ff;font-weight:400">1</span></div></div><br />这会在前一个和下一个被被放置的控件之间留下一个间隔.<br /><br /><code>Form.nextrely</code><br />&emsp;下一个控件在创建时,在y轴上的定位.当每个控价被加进窗口的时候,标准的窗口都会把它设置成 上一个已被创建的控件 的下一行.<br /><br /><code>nextrelx</code><br />&emsp;下一个控件被创建时在 x 轴上的位置.<br /><br /><strong><h3>标准窗口的其他特性</h3></strong><br /><br /><code>Form.create</code><strong><span style="color:#2980b9;">()</span></strong><br />&emsp;该方法由窗口的构造函数调用.默认它什么也不做-它是准备让你在子类中覆盖此属性的,不过它是配置窗口上的所有控件的最佳位置.所以,就等着这个方法装满 self.add()方法 调用吧!<br /><br /><code>Form.while_editing</code><strong><span style="color:#2980b9;">()</span></strong><br />&emsp;这个方法在用户在控件之间移动时被调用.它也是打算让你在子类中覆盖的,做一些比如,让一个控件按于另一个的值改变之类的事情.<br /><br /><code>Form.adjust_widgets</code><strong><span style="color:#2980b9;">()</span></strong><br />&emsp;用这个方法的时候要很小心.窗口被编辑的时候时每一次按键时它都被调用,并且没法确保它是否会被调用的更频繁.默认情况下它不做什么,并且是打算让你来覆盖定义的.鉴于它被如此频繁地调用,这里大意的话就要拖慢你的整个应用了.<br />&emsp;比如,在重绘整个窗口(这是一个缓慢的操作)就需要尽量保守一点-要确保在代码中验证是否每个重绘都必要,并且试着只重绘那些真的需要被改变的控件,而不是重绘整个屏幕.<br />&emsp;如果窗口的 parentApp(上一级的应用对象)也有一个叫做 adjust_widgets的方法,它也会被调用到.<br /><br /><code>Form.while_waiting</code><strong><span style="color:#2980b9;">()</span></strong><br />&emsp;如果你希望在等待用户按下某个键时执行动作,你可以定义一个 while_waiting 方法.同时你还要设置 keypress_timeout 属性,该值以毫秒(ms)为单位.每当等待输入时,如果超过了由 keypress_timeout传递的给定时间, while_waiting 就会被调用.注意,npyscreen没有采取什么步骤来保证 while_waiting 按照确切整齐的间隔被调用,实际上要是用户持续地按键,它可能永远也不会被调用到.<br />&emsp;如果一个窗口的上级应用对象 parentApp有一个叫 while_waiting 的方法的话,它也会被调用.<br />&emsp;假定用户没有其它动作, keypress_timeout 的值为 10 的话,就意味着 while_waiting方法每一秒都会被调用.<br />&emsp;参见内含的例子 Example-waiting.py 文件来阅读完整的示例.[<a href="https://github.com/npcole/npyscreen">https://github.com/npcole/npyscreen</a>]<br /><br /><code>Form.keypress_timeout</code><br />&emsp;参见上面的 while_waiting方法.<br /><br /><code>Form.set_value</code><strong><span style="color:#2980b9;">(</span></strong><strong>value</strong><strong><span style="color:#2980b9;">)</span></strong><br />&emsp;将值存到窗口对象的 .value 属性中,并且如果有的话,调用它的每一个控件的 whenParentChangeValue 方法.<br /><br /><strong><h3>显示并编辑窗口</h3></strong><br /><br /><code>Form.display</code><strong><span style="color:#2980b9;">()</span></strong><br />&emsp;重绘窗口及其每个控件.<br /><br /><code>Form.DISPLAY</code><strong><span style="color:#2980b9;">()</span></strong><br />&emsp;重绘窗口,并额外确认显示器被重置.这是一个缓慢的操作,要尽量避免调用它.你有些时候可能需要使用到它,比如外部进程破坏了终端.<br /><br /><code>Form.edit</code><strong><span style="color:#2980b9;">()</span></strong><br />&emsp;允许用户交互式地编辑每个控件的值.如果正确的使用 NPSAppManaged类,你应该不需要用到这个方法.可能的话要尽量避免调用该方法,写简单应用而用不上NPSAppManaged类的时候,你可能需要用到它.直接调用该方法跟类似于在GUI应用中创建一个模式对话框(模态框,覆盖在父窗体上的子窗体).尽可能把该方法当成一个内部的API调用.<br /><br /><strong><h3>窗口退出的情况</h3></strong><br /><br />&emsp;因为很多原因窗口可能需要退出其编辑模式.在 NPSAppManaged应用中,进行管理的应用可能会迫使其窗口退出.<br />&emsp;其实,自行把 .editing 属性设定为 False,也会导致窗口退出.<br /><br /><strong><h3>标准窗口类</h3></strong><br /><br />class <code>Form</code><br />&emsp;基本的窗口类.当编辑窗口的时候,用户可以通过选择右下角的 "OK"按钮来退出.<br />&emsp;默认情况下,窗口会填满终端.弹出式窗口只是具有更小的默认大小的窗口.<br /><br />class <code>Popup</code><br />&emsp;弹出式窗口只是个默认大小更小的窗口.<br /><br />class <code>ActionForm</code><br />&emsp;动作窗口 ActionForm 将创建 OK/确认 和 cancel/取消 按键.选择任一个都会退出窗口.当窗口退出时(假设是用户选择了这之中的一个按钮) on_ok 或 on_cancel 方法将被调用.因此,在子类中覆盖其中一个或者两个会很有用,默认地它们什么也不做.<br />&emsp;<code>on_ok</code><strong><span style="color:#555555;">()</span></strong><br />&emsp;    按下 ok 按钮的时被调用.设置该方法的 .editing属性为 True 会中止窗口的编辑.<br />&emsp;<code>on_cancel</code><strong><span style="color:#555555;">()</span></strong><br />&emsp;    当按下 cancel按钮的时候被调用.设置该方法的 .editing属性为 True 会中止窗口的编辑.<br /><br />class <code>ActionFormV2</code><br />&emsp;在4.3.0版本中被新加入.这个 ActionFormV2 版本的动作跟前面的 ActiveForm类似,但是代码更清爽.它应该更容易子类化.最终这个版本应该会完全取代 ActionForm.<br /><br />class <code>ActionFormMinimal</code><br />&emsp;于4.4.0版本被新加入.这个版本的 ActionFormV2只有一个 OK 按钮.按用户的用于特殊情况的要求被添加.<br /><br />class <code>ActionPopup</code><br />&emsp;是 ActionForm 的小一点的版本.<br /><br />class <code>SplitForm</code><br />&emsp;SplitForm中间有一个水平线.其 get_half_way()属性会给出它被绘制的位置.<br />&emsp;<strong>draw_line_at</strong><br />&emsp;    改属性定义了 要横穿屏幕来绘制的横线 的位置.他可以通过传递 draw_line_at= 到构造函数来设置,或者根据 get_half_way 方法的返回值自动设定.<br />&emsp;<code>get_half_way</code><strong><span style="color:#555555;">()</span></strong><br />&emsp;    返回穿过窗口中间的横线的y轴坐标.实际上在此窗口的子类中,也没有出于什么特别的原因,就应该让y轴坐标在实际上位于 窗口向下刚好一半的位置,其实子类可会返回任何方便的值.<br />&emsp;<strong>MOVE_LINE_ON_RESIZE</strong><br />&emsp;    这个类属性指定了当窗口调整大小时,横线的位置是否应该要被移动.因为横线下面的所有的控件也都需要被移动(设想到该窗口的子类中 resize方被覆盖了的情况,该值默认被设为 False).<br /><br />class <code>FormWithMenus</code><br />&emsp;类似于 Form类,但是提供了弹出菜单的附加功能.<br />&emsp;要添加新菜单到窗口,请使用 new_menu(name='')方法.这样会创建菜单并返回其代理.更多细节参见下面菜单部分.<br /><br />class <code>ActionFormWithMenus</code><br />&emsp;类似于 ActionForm类,但是提供了弹出菜单的附加功能.<br />&emsp;要添加新菜单到窗口,请使用 new_munu(name='')方法.这样会创建菜单并返回其代理对象.更多细节参见下面菜单部分.<br /><br />class <code>ActionFormV2WithMenus</code><br />&emsp;在4.3.0版本被新加入.这个版本的 ActionFormWithMenu 动作跟上面的 ActionForm类似,只是代码更加清爽.在子类中用起来应该更容易.最终这个版本应该会完全取代 ActionFormWithMenus.<br /><br />class <code>FormBaseNew</code><br />&emsp;这个窗口默认没有 ok/确认 或 cancel/取消 按钮.在该窗口被编辑前后,其 pre_edit_loop(之前) 和 post_edit_loop(之后) 附加方法会被调用.在默认版本中它们什么也不做.该类准备用作更复杂用户界面的基础.<br />&emsp;<code>pre_edit_loop</code><strong><span style="color:#555555;">()</span></strong><br />&emsp;    窗口开始被编辑之前被调用.<br />&emsp;<code>post_edit_loop</code><strong><span style="color:#555555;">()</span></strong><br />&emsp;    在编辑循环退出之后被调用.<br /><br />class <code>FormBaseNewWithMenus</code><br />&emsp;FormBaseNew 的启用了菜单的版本.<br /><br /><strong><h3>类Mutt(字符邮件客户端)窗口</h3></strong><br /><br />class <code>FormMutt</code><br />&emsp;受 mutt(一个字符界面邮件客户端) 或 irssi(一个字符界面IRC程序) 用户界面的启发,这种窗口定义了4种默认控件:<br />&emsp;<strong>wStatus1</strong><br />&emsp;    它在屏幕的顶部.你可以通过改变窗口的 STATIS_WIDGET_CLASS 类属性来改变要使用的控件的类型(注意,这个类属性在两个状态信息行里都要用到).<br />&emsp;<strong>wStatus2</strong><br />&emsp;    它占据了屏幕的倒数第二行.你可以通过改变窗口的 STATIS_WIDGET_CLASS 类属性来改变要使用的控件的类型(注意,这个类属性在两个状态信息行里都要用到).<br />&emsp;<strong>wMain</strong><br />&emsp;    它占据 wStatus1 和 wStatus2之间的区域,并且是一个多行控件.你可以改变展现在这里的控件的类型,通过创建子类继承 FormMutt,然后改变 MAIN_WIDGET_CLASS类属性来做到.<br />&emsp;<strong>wCommand</strong><br />&emsp;    这个区域占据屏幕的最后一行.你可以通过改变 STATIS_WIDGET_CLASS 类属性来改变使用的控件的类型.<br />&emsp;默认情况, wStatus1 和 wStatus2 都把 editable 属性设为了 False.<br /><br /><strong>FormMuttActive, FormMuttActiveWithMenus, FormMuttActiveTraditional, FormMuttActiveTraditionalWithMenus</strong><br />&emsp;这些类都是用来让创建更复杂的应用更容易的.它们每一个类都用了额外的类 NPSFilteredDataBase, ActionControllerSimple, TextCommandBox, TextCommandBoxTraditional.<br />&emsp;一个常见的 *nix 风格终端应用对象(用于向 mutt和 irssi这样的程序的)都有一个带有时间列表或栅格的中心显示框,一个底部的命令行,还有一些状态信息行.<br />&emsp;这些类让配置一个类似的窗口变得容易. FormMuttActive 和 FormMuttActiveTraditional 类的不同点在于,后者中,用户最终实质上唯一编辑的控件,是屏幕底部的命令行控件.不过,如果这些控件没有在编辑命令行的时候,按键动作会被传递到显示器中间的多行控件里,可以允许用户来回滚动并选择屏幕上的条目.<br />&emsp;实际上什么被显示到屏幕上,是由 ActionControllerSimple类控制的,它是不用任何单独的控件作为存储数据的基础,而是用 NPSFilteredDatabase类.<br />&emsp;更多信息参见该文档后续的 编写类Mutt应用程序 部分.<br /><br /><strong><h3>多页面窗口</h3></strong><br /><br />class <code>FormMultiPage</code><strong><span style="color:#2980b9;">(</span></strong><strong>于2.0pre63版本新加入</strong><strong><span style="color:#2980b9;">)</span></strong><br />&emsp;这个实验性的类添加了多页面窗口的支持.默认情况下,在一个页面上向下滚动超出上最后一个控件,就会移动到下一个页面,而从第一个控件继续向上移动就会回到上一页面.<br />&emsp;默认的该类会你把所在的页面显示在屏幕的右下角,如果 display_page 属性为 True 且页面多于一个的话.你也可以把 display_pages=False 传递给其构造函数.显示用的颜色存在 pages_label_color 属性中.默认它的值是 'NORMAL'.其他好用的值有‘STANDOUT’, ‘CONTROL’ 或者 ‘LABEL’.同样,你也能把他们传入构造函数.<br />&emsp;注意这个类是<strong>实验性的</strong>.API还在检查中,并且在以后的版本中可能会有所更改.它是准备用于那些不得不动态创建窗口的应用程序上的,它们可能需要创建单个比屏幕还要大的窗口(比如一个要显示服务器所指定的 xmpp表 的Jabber 客户端).它<strong>不是</strong>用来显示任意大的表单的.如果是打算那样的话, multiline类的控件可能会高效得多.<br /><br />&emsp;有3个新的方法被加到该窗口对象中:<br /><code>FormMultiPage.add_page</code><strong><span style="color:#2980b9;">()</span></strong><br />&emsp;用于窗口的创建时期.这会添加一个新的页面,并且重置新控件添加点的位置.新添的页面索引[页数]将被返回.<br /><br /><code>FormMultiPage.switch_page</code><strong><span style="color:#2980b9;">(</span></strong><strong>*index*</strong><strong><span style="color:#2980b9;">)</span></strong><br />&emsp;该方法将 激活页 改为由 index 指定的页面.<br /><br /><code>FormMultiPage.add_widget_intelligent</code><strong><span style="color:#2980b9;">(</span></strong><strong>*args</strong><strong><span style="color:#2980b9;">, </span></strong><strong>**keywords</strong><strong><span style="color:#2980b9;">)</span></strong><br />&emsp;该方法会添加一个控件到窗口.如果当前页面没有足够的空间,它会尝试创建一个新页面然后再把控件加到那儿.注意如果用户已经指定了 阻止控件被显示出来的选项 的话,即使在新页面上这个方法可能依然会抛出异常.<br /><br />class <code>FormMultPageAction</code><strong><span style="color:#2980b9;">(</span></strong><strong>new in version 2.0pre64</strong><strong><span style="color:#2980b9;">)</span></strong><br />&emsp;这是一个 FormMultiPage类的<strong>实验性</strong>版本,它添加了 on_ok 和 on_cancel方法到 ActionForm类,并且在页面的最后自动创建 cancel/取消 和 ok/确认 按钮.<br /><br />class <code>FormMultiPageWithMenus</code><br />&emsp;MultiPage的启用了菜单的版本.<br /><br />class <code>FormMultiPageActionWithMenus</code><br />&emsp;MultiPageAction的启用了菜单的版本.<br /><br /><strong><h3>菜单</h3></strong><br /><br />一些窗口支持使用弹出窗口.理论上菜单也可以作为独立的控件来使用.我们选择使用弹出菜单(实际上受RiscOS的菜单系统启发)而不是下拉菜单,因其更适合键盘环境使用,并更好的利用可用的屏幕空间同时也更容易部署到各种大小的终端环境中.<br />默认,下层支撑的窗口会显示一个菜单系统可以配置的广告页给用户,以及一个菜单的快捷键列表.如果窗口有多个菜单,那么会显示一个'root'菜单会把它们全部列出来.<br />菜单通常是调用(下层支撑)窗口的 new_menu 方法创建的.在2.0pre82版本中向该方法添加了 shortcut=None 参数.在窗口显示的菜单列表中,其快捷键信息会被显示出来.在一个菜单被创建之后,下面的方法对该菜单对象可用:<br /><br /><code>NewMenu.addItem</code><strong><span style="color:#2980b9;">(</span></strong><strong>text=''</strong><strong><span style="color:#2980b9;">, </span></strong><strong>onSelect=function</strong><strong><span style="color:#2980b9;">, </span></strong><strong>shortcut=None</strong><strong><span style="color:#2980b9;">, </span></strong><strong>arguments=None</strong><strong><span style="color:#2980b9;">, </span></strong><strong>keywords=None</strong><strong><span style="color:#2980b9;">)</span></strong><br />&emsp;text应该是菜单上显示的字符串. onSelect 应该是对应菜单项被用户选中后需要调用的一个函数.这是几个容易在 npyscreen 中创建循环引用的几率较高的地方之一 -你可能会想的传进来一个代理而不是函数本身.我一直在尽力保护你远离循环引用,但是在很多这种时刻里,我没法猜测出你的应用程序结构,这里只是其中一次.在2.0pre82版本为该方法增加了添加快捷键的能力.<br />&emsp;从3.6版本以后菜单项可以使用 arguments 的列表 再加上 或者仅仅[独立使用] 一个关键字字典来指定.<br /><br /><code>NewMenu.addItemsFromList</code><strong><span style="color:#2980b9;">(</span></strong><strong>item_list</strong><strong><span style="color:#2980b9;">)</span></strong><br />&emsp;该函数的参数应该是一个列表或者元组.其中的每个元素都应该是一个用来创建各个菜单项的参数元组.该方法已经<strong>废弃</strong>,并且可能在以后的版本中被移除或者修改.<br /><br /><code>NewMenu.addNewSubmenu</code><strong><span style="color:#2980b9;">(</span></strong><strong>name=None</strong><strong><span style="color:#2980b9;">, </span></strong><strong>shortcut=None</strong><strong><span style="color:#2980b9;">, </span></strong><strong>preDisplayFunction=None</strong><strong><span style="color:#2980b9;">, </span></strong><strong>pdfuncArguments=None</strong><strong><span style="color:#2980b9;">, </span></strong><strong>pdfuncKeywords=None</strong><strong><span style="color:#2980b9;">)</span></strong><br />&emsp;创建一个子菜单(返回其代理).这是创建子菜单的最佳方式.在2.0pre82该方法增加了添加快捷键的能力.<br />&emsp;从3.7版本之后,你可以在这个菜单显示之前定义一个被调用的函数和相关参数.这可能意味着你可以在菜单显示的位置调整其的内容.按照用户要求添加.<br /><br /><code>NewMenu.addSubmenu</code><strong><span style="color:#2980b9;">(</span></strong><strong>submenu</strong><strong><span style="color:#2980b9;">)</span></strong><br />&emsp;将一个已经存在的菜单添加到菜单中作为子菜单.综合考虑, addNewSubmenu通常都是更好的选择.<br />(在内部,这个菜单系统被叫做"新"菜单系统 -它替代了我一直不怎么喜欢的下拉菜单系统)<br /><br /><strong><h3>调整窗口大小(2.0pre88版本新添加)</h3></strong><br /><br />当窗口的大小被调整,会有一个信号发往当前屏幕上正在显示的窗口.该窗口是否处理它取决于3件事.<br /><br />如果你设置 npyscreen.DISABLE_RESIZE_SYSTEM 变量为 True.窗口将完全不会调整大小.<br />类属性 ALLOW_RESIZE(默认 =True).<br />&emsp;如果它被设置为 False,窗口也不会调整其大小.<br />类属性 FIX_MINIMUM_SIZE_WHEN_CREATED 控制着窗口是在创建时是否可以被创建的比原有大小更小.默认它被设为 False.这是因为十多年来,npyscreen都假设窗口不会改变大小,并且很多程序都依赖于窗口永远都不会被改变大小这一事实.如果你是在从头开始写新代码,你可以把这个值设成 True,倘若你测试过其结果能确保调整窗口的大小不会让你的应用程序奔溃就可以.<br /><br />在一个窗口调整大小的时候,当新的窗口大小被确定之后 resize 方法会被调用.窗口中可以覆盖此方法,来将控件移动到新的位置,或者改变任何有关窗口布局的其他适当的东西.<br /><br />当你使用 NPSAppManaged系统的时候,窗口会在显示之前被自动调整好大小.<br /></div></div>
</body></html>