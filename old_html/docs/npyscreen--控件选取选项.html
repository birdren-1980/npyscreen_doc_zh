<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>控件:选取选项</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="styles.css" type="text/css" />
</head>
<body><div class="main"><div class="tree">
<p><strong>Index</strong></p>
<p><a href="npyscreen.html">npyscreen</a></p>

<ol>
<li><a href="npyscreen--npyscreen介绍.html">npyscreen介绍</a></li>
<li><a href="npyscreen--创建npyscreen应用程序.html">创建npyscreen应用程序</a></li>
<li><a href="npyscreen--Application应用对象.html">Application应用对象</a></li>
<li><a href="npyscreen--Form窗口对象.html">Form窗口对象</a></li>
<li><a href="npyscreen--控件基本特性.html">控件:基本特性</a></li>
<li><a href="npyscreen--控件显示文本.html">控件:显示文本</a></li>
<li><a href="npyscreen--控件选取选项.html">控件:选取选项</a></li>
<li><a href="npyscreen--控件树表与树的显示.html">控件:树表与树的显示</a></li>
<li><a href="npyscreen--控件日期,滑块和复合控件.html">控件:日期,滑块和复合控件</a></li>
<li><a href="npyscreen--控件网格.html">控件:网格</a></li>
<li><a href="npyscreen--控件其他控制.html">控件:其他控制</a></li>
<li><a href="npyscreen--控件标题控件.html">控件:标题控件</a></li>
<li><a href="npyscreen--控件控件框.html">控件:控件框</a></li>
<li><a href="npyscreen--按键绑定全解.html">按键绑定全解</a></li>
<li><a href="npyscreen--增强鼠标支持.html">增强鼠标支持</a></li>
<li><a href="npyscreen--色彩支持.html">色彩支持</a></li>
<li><a href="npyscreen--显示简讯通知及选项.html">显示简讯通知及选项</a></li>
<li><a href="npyscreen--清空屏幕.html">清空屏幕</a></li>
<li><a href="npyscreen--应用支持.html">应用支持</a></li>
<li><a href="npyscreen--编写更复杂的窗口.html">编写更复杂的窗口</a></li>
<li><a href="npyscreen--编写测试.html">编写测试</a></li>
<li><a href="npyscreen--示例程序一个简单的通讯录.html">示例程序:一个简单的通讯录</a></li>
</ol></div>
<div class="page"><h1><b><u>控件:选取选项</u></b></h1><strong><h2>控件:选取选项</h2></strong><br /><br />MultiLine<br />&emsp;向用户给出一个选项列表.(该控件可能应该可以有一个更好的名字,但是我们现在先这样吧)<br />&emsp;所有的选型都应该以列表形式被存在 values属性中. value属性里保存了用户所选项的索引.如果你希望返回用户实际选择的值而不是某个索引,请使用 get_selected_objects()方法.<br />&emsp;MultiLine 及其衍生类的最重要的特性之一就是,它们可以很容易的被适配用来让用户选择不同类型的对象.要那么做,请覆盖 display_value(self, vl)方法.其中 vl 参数会是被显示的对象,而函数应该会返回一个能被显示到屏幕上的字符串.<br />&emsp;换句话说,你可以传入一个任意类型的对象的列表.默认,他们会被显示成 str()后的结果,但是通过重写 display_value 你可以用任何你认为合适的方式展示它们.<br />&emsp;MultiLine也会允许用户'过滤'条目.(已绑定按键 I,L,n,p默认是 过滤器,清除过虑器,下一个和上一个).当前的实现会高亮显示屏幕上匹配的行.未来的版本可能会隐藏其他的行或者给出一个选项[要如何处理].你可以通过覆盖 filter_value方法 来控制过滤器如何进行操作.它应该接收一个索引作为参数(用来在 .values列表 中找到某一行)并且应该对匹配的项返回 True, 其他的返回 False.从2.0pre74版本开始,整改过滤系统可以通过设置 .allow_filtering为False来禁用.该项也可以作为参数传递到构造函数中.<br />&emsp;MultiLine控件是一个容器控件,用来容纳一系列的其他控件,由它们来进而处理各个要显示的部分.所有的多行控件类都会有一个 _containded_widget 类属性.他可以控制控件对象如何被构建.其 _contained_widget_height 类属性指定了每个控件应该给屏幕上的多少行.<br />TitleMultiLine<br />&emsp;一个 MultiLine的带标题的版本.<br />&emsp;如果你要创建自己的 MultiLine的子类,你可以通过子类化该对象,然后修改类的 _entry_type 变量就能创建一个带标题的版本了.<br />MultiSelect,TitleMultiSelect<br />&emsp;向用户给出一个选项的列表,允许他/她选择其中的多个.<br />&emsp;其 value属性是一个用户所选项的索引的列表.与 MultiLine控件一样,选项的列表存放在 values属性中.<br />SelectOne,TitleSelectOne<br />&emsp;功能上,这些类跟 MultiLine 版本的差不多,但是显示的跟 MultiSelect控件更相似.<br />MultiSelectFixed,TitleMultiSelectFixed<br />&emsp;这些 MultiSelect特殊版本其实是用来显示数据的,但是像 Textfixed一样,不允许用户实际去编辑它们.<br />MultiLineAction<br />&emsp;这种控件的一个常见的使用场景就是,在用户按下回车,空格等等时,对当前高亮的条目执行一个动作.覆盖该类的 actionHighlighted(self, act_on_this, key_press) 方法就能做出这些控件.此方法会在用户'选中'一个条目时被调用(虽然这种情况下 .value实际还没被设定),并且会被传递进高亮的条目以及用户实际按下的键.<br />MultiSelectAction<br />&emsp;这个跟上面的 MultiLineAction控件类似,只是它还提供 actionSelected(self, act_on_these, keypress)方法.它能被覆盖,并且如果用户按下';'(分号)键它会被调用.这个函数会收到被选择的对象的列表和按下的键.你可能会想调整其默认的按键绑定,把这个控件变得有用.<br />BufferPager, TitleBufferPager 在2.0pre90版本中新加入<br />&emsp;BufferPager 类似是 Pager[页面控件] 类的一个子类.它被设计用来把文本向用户显示地尽量类似于 tail -f 在 <span style="color:#0000ff;">*</span>nix 环境下的动作方式.默认,其 .value 属性被设定为一个 collections.deque 类的实例.你可以传递 maxlen=value 到其构造函数.如果没有, deque[双向队列]对象的 maxlen(最大长度)会从 DEFAULT_MAXLEN 类属性中获取,而它默认是 None.<br />&emsp;<code>BufferPager.clearBuffer</code><strong><span style="color:#2980b9;">()</span></strong><br />&emsp;&emsp;清空缓存.<br />&emsp;<code>BufferPager.buffer</code><strong><span style="color:#2980b9;">(</span></strong><strong>lines</strong><strong><span style="color:#2980b9;">, </span></strong><strong>scroll_end=True</strong><strong><span style="color:#2980b9;">, </span></strong><strong>scroll_if_editing=False</strong><strong><span style="color:#2980b9;">)</span></strong><br />&emsp;&emsp;将 lines 添加到所包含的双向队列对象中.如果 scroll_end 为 True, 这滚动到缓冲区的结尾.如果 scroll_if_editing 为 True,那么即使用户当前正在编辑 Pager[页面控件] 也会滚动到末尾.如果包含的双向队列对象在创建时被指定了最大长度,新添加的数据可能会导致旧数据被遗忘.<br />MultiLineEditable<br />&emsp;一个用户可以编辑的选项列表,基于 MultiLine 类.在3.9版本中新加入.<br />&emsp;<code>get_new_value</code><strong><span style="color:#2980b9;">()</span></strong><br />&emsp;&emsp;这个方法应该会返回一个可以用来初始化列表中的一个新选项的'空白的'对象.默认它返回一个空字符串.<br />MultiLineEditableTitle<br />&emsp;MultiLineEditable 的带标题的版本.其 _entry_type 类属性控制着容纳的控件的类型.<br />MultiLineEditableBoxed<br />&emsp;MultiLineEditable 的带框版本.其  <span style="color:#0000ff;">**</span>_entry_type* 类属性控制着容纳的控件的类型.[*号代表通配,而非具体名称]<br /><br /><strong><h3>自定义多选控件</h3></strong><br /><br />多行控件是一个容器类型的控件,其中容纳一系列用于处理各部分的其他显示控件.所有的多行控件类都有一个 _contained_widget 类属性.它可以控制控件是如何被构造. _contained_widget_height 指定了应该给各个控件多少屏幕上的行.<br /><br />从3.4版本以后,被包含的带有 .selected 属性的控件的处理有所不同: 如果它的行被选中,则把它们的 .selected 属性设置为 True,否则为 False.控件的 .important 属性可能一会被设置为 True或 False,取决于他们是否被当前的 filter过虑器所包含(参见上面).<br /><br />没有 selected属性的控件,它们的每一行的值会被放到 name 属性中,并且不论是否被选中的行都会被放到它们的 value 属性中.这是一个既有的遗留问题,因为实际上上标准的多选控件使用多个选框[checkboxes]来显示每一行.<br /><br />从4.8.7版本以后,多行控件都开始使用 set_is_line_important, set_is_line_bold 和 set_is_line_cursor 方法来控制每个被显示的行.这些方法会被传递进待选择的控件对象和一个布尔值.它们都是打算用来被覆盖的.<br /><br /></div></div>
</body></html>