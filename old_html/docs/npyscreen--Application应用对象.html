<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Application应用对象</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="styles.css" type="text/css" />
</head>
<body><div class="main"><div class="tree">
<p><strong>Index</strong></p>
<p><a href="npyscreen.html">npyscreen</a></p>

<ol>
<li><a href="npyscreen--npyscreen介绍.html">npyscreen介绍</a></li>
<li><a href="npyscreen--创建npyscreen应用程序.html">创建npyscreen应用程序</a></li>
<li><a href="npyscreen--Application应用对象.html">Application应用对象</a></li>
<li><a href="npyscreen--Form窗口对象.html">Form窗口对象</a></li>
<li><a href="npyscreen--控件基本特性.html">控件:基本特性</a></li>
<li><a href="npyscreen--控件显示文本.html">控件:显示文本</a></li>
<li><a href="npyscreen--控件选取选项.html">控件:选取选项</a></li>
<li><a href="npyscreen--控件树表与树的显示.html">控件:树表与树的显示</a></li>
<li><a href="npyscreen--控件日期,滑块和复合控件.html">控件:日期,滑块和复合控件</a></li>
<li><a href="npyscreen--控件网格.html">控件:网格</a></li>
<li><a href="npyscreen--控件其他控制.html">控件:其他控制</a></li>
<li><a href="npyscreen--控件标题控件.html">控件:标题控件</a></li>
<li><a href="npyscreen--控件控件框.html">控件:控件框</a></li>
<li><a href="npyscreen--按键绑定全解.html">按键绑定全解</a></li>
<li><a href="npyscreen--增强鼠标支持.html">增强鼠标支持</a></li>
<li><a href="npyscreen--色彩支持.html">色彩支持</a></li>
<li><a href="npyscreen--显示简讯通知及选项.html">显示简讯通知及选项</a></li>
<li><a href="npyscreen--清空屏幕.html">清空屏幕</a></li>
<li><a href="npyscreen--应用支持.html">应用支持</a></li>
<li><a href="npyscreen--编写更复杂的窗口.html">编写更复杂的窗口</a></li>
<li><a href="npyscreen--编写测试.html">编写测试</a></li>
<li><a href="npyscreen--示例程序一个简单的通讯录.html">示例程序:一个简单的通讯录</a></li>
</ol></div>
<div class="page"><h1><b><u>Application应用对象</u></b></h1><strong><h2>Application 对象</h2></strong><br /><br />NPSAppManaged 提供一个开始和结束应用程序的框架,来管理你创建的各种窗口的显示,并以一种不会产生出递归深度问题的方式完成.<br /><br />除非你有什么特别好的理由要用其他方式,否则 NPSAppManaged 应该确定会是管理你的应用的最好方法了.<br /><br />不像原始的 NPSApp 类那样,你不用自己写主循环, NPSApp 会管理好你的应用的每个窗口的显示.设定好你的窗口对象,然后只需要简单的调用你的 NPSAppManaged 实例的 .run() 方法就可以了.<br /><br /><strong><h3>让NPSAppManaged管理你的窗口</h3></strong><br /><br />有3种方法来用 NPSAppManaged 实例注册一个窗口对象:<br /><br /><code>NPSAppManaged.addForm</code><strong><span style="color:#2980b9;">(</span></strong><strong>*id*</strong><strong><span style="color:#2980b9;">, </span></strong><strong>*FormClass*</strong><strong><span style="color:#2980b9;">, </span></strong><strong>...</strong><strong><span style="color:#2980b9;">)</span></strong><br />&emsp;在种版本的写法会先创建一个新的窗体然后用 NPSAppManaged 实例注册它.它从窗口对象返回一个 weakref.proxy [弱引用的对象代理],它的 .id 应该是一个可以唯一标识该窗口的字符串.任何额外的参数都会别传递到该窗口的构造函数中[用来指定窗口的创建规格].如果你没在其他地方单独存放窗口的引用,就用这种写法.<br /><br /><code>NPSAppManaged.addFormClass</code><strong><span style="color:#2980b9;">(</span></strong><strong>*id*</strong><strong><span style="color:#2980b9;">, </span></strong><strong>*FormClass* ...</strong><strong><span style="color:#2980b9;">)</span></strong><br />&emsp;这种写法注册一个窗口类而不是一个实例.每次被编辑完都会有一个新实例被创建.每次创建的时候额外的参数会被传递到窗口的构造函数中.<br /><br /><code>NPSAppManaged.registerForm</code><strong><span style="color:#2980b9;">(</span></strong><strong>id</strong><strong><span style="color:#2980b9;">, </span></strong><strong>fm</strong><strong><span style="color:#2980b9;">)</span></strong><br />&emsp;id在这是一个唯一标识窗口的字符串.而 .fm 需要是一个窗口对象.注意,跟 .addForm()写法比起来 -这种写法只会在 NPSAppManaged 中存放一个weakref.proxy.<br /><br />所有用 NPSAppManaged 注册的窗口都可以用 self.parentApp 来访问到应用对对象的控制.<br /><br />若你因为什么原因需要删除一个窗口,你可以用 .removeForm(*id*)方法来做到.<br /><br /><strong><h3>运行NPSAppManaged应用</h3></strong><br /><br /><code>run</code><strong><span style="color:#2980b9;">()</span></strong><br />&emsp;开始一个 NPSAppManaged 应用的主循环. 该方法会激活默认的窗口,并且应该用 "MAIN" 来作它的指定 id .<br /><br /><code>NPSAppManaged.STARTING_FORM</code><br />&emsp;如果你出于什么原因要改默认窗口的名称,你可以在这改.<br /><br />一旦程序开始运行,下面的方法会控制向用户展示哪个窗口.<br /><br /><code>NPSAppManaged.setNextForm</code><strong><span style="color:#2980b9;">(</span></strong><strong>formid</strong><strong><span style="color:#2980b9;">)</span></strong><br />&emsp;设定在当前窗口退出后,要显示的窗口.<br /><br /><code>NPSAppManaged.setNextFormPrevious</code><strong><span style="color:#2980b9;">()</span></strong><br />&emsp;设定在当前窗口退出时要显示的窗口为 历史记录里之前工作的那个窗口 <br /><br /><code>NPSAppManaged.switchForm</code><strong><span style="color:#2980b9;">(</span></strong><strong>formid</strong><strong><span style="color:#2980b9;">)</span></strong><br />&emsp;立即切换到指定的窗口,绕过一切当前窗口的退出逻辑.<br /><br /><code>NPSAppManaged.switchFormPrevious</code><strong><span style="color:#2980b9;">()</span></strong><br />&emsp;立即切换到历史记录中之前工作的窗口.<br /><br /><strong><h3>细节说明</h3></strong><br /><br />当你所有的窗口都准备就绪并且已经用 NPSAppManaged 实例注册完成,你就该调用 .run() 方法了.<br /><br />这个方法会激活默认的窗口,默认窗口应该是用"MAIN"为 id 的.这个默认的 id可以通过修改类或者实例的 .STRING_FORM 变量来调整.<br /><br />之后,下一个被显示的窗口将会被一个叫 NEXT_ACTIVE_FORM 的变量指定.不管什么时候当一个窗口的编辑循环退出了,该窗口这个变量所指定的新窗口都会被激活.如果此时 NEXT_ACTIVE_FORM 是空值 None,主循环就会退出.<br />NEXT_ACTIVE_FORM 应该通过调用应用的 setNextForm(formid)方法来配置.这份文档在过去建议直接设置该属性.虽然还没有立即弃用该属性的计划,还是应该避免去直接设定它.<br /><br />有3中在窗口中应该可以用来控制 NEXT_ACTIVE_FORM 的机制.<br /><br />1.所有用 NPSAppManaged 注册的窗口,若没有 .activate() 的特殊方法的话,它们的 .afterEditing() 方法会被调用,如果后者有的话.判定 NEXT_ACTIVE_FORM 应该是哪个的逻辑内容,应该是放在这进行的.<br />  NEXT_ACTIVE_FORM 应该是通过调用应用的 setNextForm(formid) 方法来配置的.如果你希望用户来选择 ok/确认 或者 cancel/取消 按钮的话, 这是你切换屏幕的首选方法.<br />2.应用的 switchForm(formid) 方法会使应用立即停止编辑当前窗口,并切换到指定的窗口.根据窗口的类型情况,它们相关联的退出逻辑可能也会被绕过.<br />3.用 NPSAppManaged 注册的窗口可能都会被赋予一个 .activate 方法, NPSAppManaged 会调用它,来取代常用的 .edit() 方法.这可能会包含额外的逻辑.这 <strong>不是</strong> 最优方法,但是却能允许有更大的灵活性.要注意在这里, 通常的 .edit 方法会不会被调用,除非你明确地指定调用它.举个栗子, 一个典型的 .active() 方法可能是这样的:<br />   <div class="codebox"><div class="codebox">&nbsp;def&nbsp;activate(<span style="color:#008a8c;font-weight:400">self</span>):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008a8c;font-weight:400">self</span>.edit()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008a8c;font-weight:400">self</span>.parentApp.setNextForm(<span style="color:#ff00ff;font-weight:400">None</span>)</div></div><br />&emsp;而这会导致主循环在窗口结束后会退出.<br /><br /><strong><h3>NPSAppManaged提供的附加服务</h3></strong><br /><br />下面这些方法可以在 NPSAppManaged 子类里有效的覆盖.默认他们什么也不做.<br /><br /><code>NPSAppManaged.onInMainLoop</code><strong><span style="color:#2980b9;">()</span></strong><br />&emsp;在程序运行时,在[切换]每个屏幕之间被调用.它不在第一个屏幕之前被调用.<br /><br /><code>NPSAppManaged.onStart</code><strong><span style="color:#2980b9;">()</span></strong><br />&emsp;覆盖该方法来执行任何初始化工作.如果你愿意,你可以在这配置你的应用的窗口.<br /><br /><code>NPSAppManaged.onCleanExit</code><strong><span style="color:#2980b9;">()</span></strong><br />&emsp;覆盖该方法以便在程序无错退出时,执行任何清理任务.<br /><br /><code>NPSAppManaged.keypress_timeout_default</code><br />&emsp;如果配置了该项,新窗口创建时会将 keypress_timeout 设置成该值(只要窗口知道自己所属的应用程序)-也就是说,它们在创建时就被传递了换一个 parentApp= 的属性.如果你使用了NPSAppManaged,这一切都是自动完成的.<br /><br /><code>NPSAppManaged.while_waiting</code><strong><span style="color:#2980b9;">()</span></strong><br />&emsp;应用都还会有一个 while_waiting 方法.你可以随意定义和覆盖它,它会在应用程序等待用户输入的时候被调用(可以参见普通窗口的 while_waiting 方法).<br /><br /><code>NPSAppManaged._internal_while_waiting</code><strong><span style="color:#2980b9;">()</span></strong><br />&emsp;该方法供 npyscreen 内部使用.<br /><br /><code>NPSAppManaged.switchForm</code><strong><span style="color:#2980b9;">(</span></strong><strong>formid</strong><strong><span style="color:#2980b9;">)</span></strong><br />&emsp;立即停止编辑当前窗口并切换到指定的窗口.<br /><br /><code>NPSAppManaged.switchFormPrevious</code><strong><span style="color:#2980b9;">()</span></strong><br />&emsp;立即切换到历史中的前一个窗口.<br /><br /><code>NPSAppManaged.resetHistory</code><strong><span style="color:#2980b9;">()</span></strong><br />&emsp;遗忘之前访问过的窗口[重置历史记录].<br /><br /><code>NPSAppManaged.getHistory</code><strong><span style="color:#2980b9;">()</span></strong><br />&emsp;获取之前访问过的窗口的列表.<br /><br /><strong><h3>由该类来管理的窗口方法和属性</h3></strong><br /><br />由 NPSAppManaged 调用的窗口可以给出的方法:<br /><br /><code>Form.beforeEditing</code><strong><span style="color:#2980b9;">()</span></strong><br />&emsp;在窗口的编辑循环被调用之前调用.<br /><br /><code>Form.afterEditing</code><strong><span style="color:#2980b9;">()</span></strong><br />&emsp;窗口退出时被调用.<br /><br /><code>Form.activate</code><strong><span style="color:#2980b9;">()</span></strong><br />&emsp;该方法的存在会完全优先于现有的 .beforeEditing .edit 和 afterEditing方法.<br /><br /><strong><h3>其他应用程序类</h3></strong><br /><br /><code>NPSApp</code> 类<br />&emsp;若要使用NPSApp,请将它置之为子类,然后给出你自己的 .main() 定义.当你准备好通过调用 .run() 运行应用程序的时候,你的主循环就会被执行.<br /><br />虽然它提供了巨大的灵活性,但是NPSApp几乎在其他的每一方面都次于NPSAppManaged.请不要在新项目中使用它,并且把它视为一个仅仅内部使用的基类.<br /></div></div>
</body></html>